(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{97:function(a,t,e){"use strict";e.r(t);var r=e(0),v=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"走进后端工程师的世界"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#走进后端工程师的世界","aria-hidden":"true"}},[a._v("#")]),a._v(" 走进后端工程师的世界")]),a._v(" "),e("h2",{attrs:{id:"前端与后端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端与后端","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端与后端")]),a._v(" "),e("ul",[e("li",[a._v("用户可以看到的属于前端")]),a._v(" "),e("li",[a._v("其他都属于后端范畴")])]),a._v(" "),e("h3",{attrs:{id:"前端程序员为什么要懂点后端"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端程序员为什么要懂点后端","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端程序员为什么要懂点后端")]),a._v(" "),e("ul",[e("li",[a._v("对系统来讲前后端都不是孤立的")]),a._v(" "),e("li",[a._v("前后端合作很重要")]),a._v(" "),e("li",[a._v("想做全栈不明白后端是个笑话")]),a._v(" "),e("li",[a._v("与后端程序员互怼时候占优势")])]),a._v(" "),e("h3",{attrs:{id:"大前端语言和技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大前端语言和技术","aria-hidden":"true"}},[a._v("#")]),a._v(" 大前端语言和技术")]),a._v(" "),e("ul",[e("li",[a._v("ES5 & ES6 & ES7  //ES语言基础")]),a._v(" "),e("li",[a._v("HTML5 & CSS3  //h5和css特效")]),a._v(" "),e("li",[a._v("Less & Sass  //CSS编译语言")]),a._v(" "),e("li",[a._v("SVG & Canvas & D3.js  //图形数据可视化")]),a._v(" "),e("li",[a._v("WebGL & Three.js  //3D场景")]),a._v(" "),e("li",[a._v("CMD & AMD & CommonJS  //语言标准")]),a._v(" "),e("li",[a._v("RequireJS & SeaJS  //ES模块化库")]),a._v(" "),e("li",[a._v("CoffeeScript & TypeScript  //ES语言风格库")]),a._v(" "),e("li",[a._v("NodeJS & Express & Koa  //Node的Web服务器")])]),a._v(" "),e("h2",{attrs:{id:"前后端分离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离","aria-hidden":"true"}},[a._v("#")]),a._v(" 前后端分离")]),a._v(" "),e("h4",{attrs:{id:"前后端分离前开发模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离前开发模式","aria-hidden":"true"}},[a._v("#")]),a._v(" 前后端分离前开发模式")]),a._v(" "),e("p",[a._v("提出需求 -> 前端开发页面 -> 翻译成模板 -> 前后端对接 -> 二次集成 -> 后端返工 -> 前端返工 -> 集成遇到问题 -> 集成成功 -> 交付上线")]),a._v(" "),e("h4",{attrs:{id:"前后端分离后开发模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离后开发模式","aria-hidden":"true"}},[a._v("#")]),a._v(" 前后端分离后开发模式")]),a._v(" "),e("p",[a._v("提出需求 -> 设计接口约定数据 -> 前后端并行开发 -> 前后端集成 -> 前端调整页面 -> 集成成功 -> 交付上线")]),a._v(" "),e("h3",{attrs:{id:"哪些情况需要前后端分离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哪些情况需要前后端分离","aria-hidden":"true"}},[a._v("#")]),a._v(" 哪些情况需要前后端分离")]),a._v(" "),e("ul",[e("li",[a._v("页面布局复杂，使用了主题和样式")]),a._v(" "),e("li",[a._v("需要有较高的页面渲染效果")]),a._v(" "),e("li",[a._v("前端页面中包含复杂业务逻辑")]),a._v(" "),e("li",[a._v("页面需要渲染的数据量较大")])]),a._v(" "),e("h3",{attrs:{id:"典型应用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#典型应用场景","aria-hidden":"true"}},[a._v("#")]),a._v(" 典型应用场景")]),a._v(" "),e("ul",[e("li",[a._v("H5游戏")]),a._v(" "),e("li",[a._v("Native开发的移动APP")]),a._v(" "),e("li",[a._v("浏览器插件")]),a._v(" "),e("li",[a._v("微信小程序")]),a._v(" "),e("li",[a._v("Electron开发的桌面应用")]),a._v(" "),e("li",[a._v("各类大型网站")])]),a._v(" "),e("h3",{attrs:{id:"前后端分离的意义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离的意义","aria-hidden":"true"}},[a._v("#")]),a._v(" 前后端分离的意义")]),a._v(" "),e("ul",[e("li",[a._v("前后端各司其职，工作各有分工")]),a._v(" "),e("li",[a._v("提高开发效率")]),a._v(" "),e("li",[a._v("完美应对前端需求的变化")]),a._v(" "),e("li",[a._v("增强代码的可维护性")])]),a._v(" "),e("h2",{attrs:{id:"前后端分离的那些套路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离的那些套路","aria-hidden":"true"}},[a._v("#")]),a._v(" 前后端分离的那些套路")]),a._v(" "),e("h4",{attrs:{id:"前后端分离前"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离前","aria-hidden":"true"}},[a._v("#")]),a._v(" 前后端分离前")]),a._v(" "),e("p",[a._v("浏览器和服务器之间，是Nginx（反向代理的一种服务，用于维护静态资源，解析URL请求并将URL请求转发到正确的服务器上，处理API请求）")]),a._v(" "),e("h4",{attrs:{id:"前后端分离后"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离后","aria-hidden":"true"}},[a._v("#")]),a._v(" 前后端分离后")]),a._v(" "),e("p",[a._v("浏览器（发送URL请求、API请求）-> 前端机 -> URL请求到NodeJS集群（前后端分离中间层，包含页面资源，负载均衡负担压力） & API请求到PHP集群（后端）；NodeJS集群通过RPC到PHP集群")]),a._v(" "),e("h4",{attrs:{id:"nodejs架构分层方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodejs架构分层方案","aria-hidden":"true"}},[a._v("#")]),a._v(" NodeJS架构分层方案")]),a._v(" "),e("h3",{attrs:{id:"前后端交互形式（通信）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前后端交互形式（通信）","aria-hidden":"true"}},[a._v("#")]),a._v(" 前后端交互形式（通信）")]),a._v(" "),e("ul",[e("li",[a._v("更多的是采用RESTful风格的接口")]),a._v(" "),e("li",[a._v("REST是“呈现状态转移”的缩写，一种API的架构风格，在客户端和服务端之间通过呈现状态的转移来驱动应用状态的演进")])]),a._v(" "),e("h3",{attrs:{id:"restful简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#restful简介","aria-hidden":"true"}},[a._v("#")]),a._v(" RESTful简介")]),a._v(" "),e("ul",[e("li",[a._v("使用GET、POST、PUT、DELETE这几种请求模式")]),a._v(" "),e("li",[a._v("get（select）从服务器抽取资源")]),a._v(" "),e("li",[a._v("post（create）在服务器创建一个资源")]),a._v(" "),e("li",[a._v("put（update）在服务器更新资源")]),a._v(" "),e("li",[a._v("delete（delete）从服务器删除资源")])]),a._v(" "),e("h3",{attrs:{id:"数据接口流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据接口流程","aria-hidden":"true"}},[a._v("#")]),a._v(" 数据接口流程")]),a._v(" "),e("p",[a._v("定制接口 -> 前端开发（mock数据）& 后端开发（后端自测） -> 联调（校验格式） -> 提测（自动化测试）")])])}],!1,null,null,null);t.default=v.exports}}]);